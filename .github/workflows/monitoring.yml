name: Synthetic Monitoring & Health Checks

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:

jobs:
  synthetic-monitoring:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Check API Health Endpoint
        id: health
        run: |
          echo "Testing health endpoint..."
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://gists-api.example.com/health)
          echo "health_status=$RESPONSE" >> $GITHUB_OUTPUT
          
          if [ $RESPONSE -ne 200 ]; then
            echo "‚ùå Health check FAILED: HTTP $RESPONSE"
            exit 1
          else
            echo "‚úÖ Health check passed: HTTP $RESPONSE"
          fi
      
      - name: Test User Endpoint (octocat)
        id: user_test
        run: |
          echo "Testing user endpoint..."
          START=$(date +%s%N)
          RESPONSE=$(curl -s -w "\n%{http_code}" https://gists-api.example.com/octocat)
          END=$(date +%s%N)
          
          STATUS=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          LATENCY=$((($END - $START) / 1000000))
          
          echo "response_time_ms=$LATENCY" >> $GITHUB_OUTPUT
          echo "status_code=$STATUS" >> $GITHUB_OUTPUT
          
          echo "üìä Response time: ${LATENCY}ms"
          echo "üì° Status code: $STATUS"
          
          if [ $STATUS -ne 200 ]; then
            echo "‚ùå API test FAILED: HTTP $STATUS"
            exit 1
          fi
          
          # Check response structure
          if echo "$BODY" | jq -e '.[] | .id, .url, .files' > /dev/null 2>&1; then
            echo "‚úÖ Response structure valid"
          else
            echo "‚ùå Invalid response structure"
            exit 1
          fi
      
      - name: Test Invalid User (404 Expected)
        run: |
          echo "Testing error handling..."
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://gists-api.example.com/nonexistentuser999999)
          
          if [ $RESPONSE -eq 404 ]; then
            echo "‚úÖ 404 handling works correctly"
          else
            echo "‚ùå Expected 404, got $RESPONSE"
            exit 1
          fi
      
      - name: Measure API Latency (Multiple Requests)
        id: latency
        run: |
          echo "Running latency tests..."
          TOTAL=0
          REQUESTS=10
          
          for i in $(seq 1 $REQUESTS); do
            START=$(date +%s%N)
            curl -s https://gists-api.example.com/octocat > /dev/null
            END=$(date +%s%N)
            LATENCY=$((($END - $START) / 1000000))
            TOTAL=$(($TOTAL + $LATENCY))
            echo "Request $i: ${LATENCY}ms"
          done
          
          AVG=$(($TOTAL / $REQUESTS))
          echo "average_latency_ms=$AVG" >> $GITHUB_OUTPUT
          echo "üìä Average latency: ${AVG}ms"
          
          # Alert if latency > 2000ms
          if [ $AVG -gt 2000 ]; then
            echo "‚ö†Ô∏è WARNING: High latency detected (${AVG}ms)"
          fi
      
      - name: Send Metrics to Prometheus Pushgateway (Optional)
        if: always()
        run: |
          cat <<EOF | curl --data-binary @- http://prometheus-pushgateway.example.com:9091/metrics/job/synthetic-monitoring
          # TYPE gist_api_health_status gauge
          gist_api_health_status{endpoint="health"} ${{ steps.health.outputs.health_status == '200' && '1' || '0' }}
          
          # TYPE gist_api_response_time_ms gauge
          gist_api_response_time_ms{endpoint="octocat"} ${{ steps.user_test.outputs.response_time_ms }}
          
          # TYPE gist_api_average_latency_ms gauge
          gist_api_average_latency_ms ${{ steps.latency.outputs.average_latency_ms }}
          EOF
        continue-on-error: true
      
      - name: Post to Slack on Failure
        if: failure()
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data '{"text":"üö® *Gist API Monitoring Alert*\n‚Ä¢ Health: ${{ steps.health.outputs.health_status }}\n‚Ä¢ Status: ${{ steps.user_test.outputs.status_code }}\n‚Ä¢ Latency: ${{ steps.user_test.outputs.response_time_ms }}ms\n‚Ä¢ Time: $(date -u)"}' \
          ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true

  load-test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install k6 (Load Testing)
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
      
      - name: Run Load Test
        run: |
          k6 run --out json=results.json - <<'EOF'
          import http from 'k6/http';
          import { check, sleep } from 'k6';
          
          export let options = {
            stages: [
              { duration: '30s', target: 10 },  // Ramp up to 10 users
              { duration: '1m', target: 10 },   // Stay at 10 users
              { duration: '30s', target: 0 },   // Ramp down
            ],
            thresholds: {
              'http_req_duration': ['p(95)<2000'], // 95% of requests < 2s
              'http_req_failed': ['rate<0.1'],     // Error rate < 10%
            },
          };
          
          export default function () {
            let response = http.get('https://gists-api.example.com/octocat');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response has gists': (r) => JSON.parse(r.body).length > 0,
            });
            sleep(1);
          }
          EOF
      
      - name: Upload Load Test Results
        uses: actions/upload-artifact@v4
        with:
          name: k6-results
          path: results.json

  ssl-certificate-check:
    runs-on: ubuntu-latest
    
    steps:
      - name: Check SSL Certificate Expiry
        run: |
          echo "Checking SSL certificate..."
          EXPIRY=$(echo | openssl s_client -servername gists-api.example.com -connect gists-api.example.com:443 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2)
          EXPIRY_EPOCH=$(date -d "$EXPIRY" +%s)
          NOW_EPOCH=$(date +%s)
          DAYS_LEFT=$(( ($EXPIRY_EPOCH - $NOW_EPOCH) / 86400 ))
          
          echo "üìÖ Certificate expires: $EXPIRY"
          echo "‚è≥ Days remaining: $DAYS_LEFT"
          
          if [ $DAYS_LEFT -lt 30 ]; then
            echo "‚ö†Ô∏è WARNING: Certificate expires in $DAYS_LEFT days!"
            exit 1
          else
            echo "‚úÖ Certificate valid for $DAYS_LEFT days"
          fi
